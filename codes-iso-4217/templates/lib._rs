use std::str::FromStr;
use std::marker::PhantomData;

#[allow(unused_imports)]
use codes_agency::{Agency, Standard, standardized_type};
#[allow(unused_imports)]
use codes_common::{code_impl, error, fixed_length_code};

#[cfg(feature = "serde")]
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};

// ------------------------------------------------------------------------------------------------
// Public Types
// ------------------------------------------------------------------------------------------------

/// An instance of the `Standard` struct defined in the
/// [`codes_agency`](https://docs.rs/codes-agency/latest/codes_agency/)
/// package that describes the ISO-4217 specification.
pub const ISO_4217: Standard = Standard::new_with_long_ref(
    Agency::ISO,
    "4217",
    "ISO 4217:2015",
    "Currency codes",
    "https://www.iso.org/iso-4217-currency-codes.html",
);

/// Trait implemented by each currency.
pub trait {{ type_name }} {{ "{" }}
    /// Get a singleton instance of this currency.
    fn get_concrete() -> &'static Self where Self: Sized;

    /// The alphabetic code is based on another ISO standard, ISO 3166, which lists the codes for
    /// country names. The first two letters of the ISO 4217 three-letter code are the same as the
    /// code for the country name, and, where possible, the third letter corresponds to the first
    /// letter of the currency name.
    ///
    /// For example:
    ///
    /// * The US dollar is represented as USD – the US coming from the ISO 3166 country code and
    ///   the D for dollar.
    /// * The Swiss franc is represented by CHF – the CH being the code for Switzerland in the ISO
    ///   3166 code and F for franc.
    fn alpha_code(&self) -> &'static str;

    /// The three-digit numeric code is useful when currency codes need to be understood in
    /// countries that do not use Latin scripts and for computerized systems. Where possible, the
    /// three-digit numeric code is the same as the numeric country code.
    ///
    /// For currencies having minor units, ISO 4217:2015 also shows the relationship between the
    /// minor unit and the currency itself (i.e. whether it divides into
    /// 100 or 1000).
    ///
    /// ISO 4217:2015 also describes historical codes in List 3, as well as the codes representing
    /// certain funds in List 2.
    fn numeric_code(&self) -> Option<u16>;

    /// The registered descriptive name of this code.
    #[cfg(feature = "currency_name")]
    fn currency_name(&self) -> &'static str;

    /// The country, or entity, that is responsible for this code.
    #[cfg(feature = "country_name")]
    fn country_name(&self) -> &'static str;

    /// The number of decimal values this code typically uses.
    #[cfg(feature = "monetary_units")]
    fn monetary_units(&self) -> Option<u8>;

    /// `true` if this code represents a fund, else `false`.
    #[cfg(feature = "is_fund")]
    fn is_fund(&self) -> bool;

    /// `true` if this code represents a historical code, else `false`.
    #[cfg(feature = "historical_codes")]
    fn is_historical(&self) -> bool;

    /// For historical codes (where `IS_HISTORICAL` is `true`), return the informal date of
    /// withdrawal.
    #[cfg(feature = "historical_codes")]
    fn withdrawal_date(&self) -> Option<&'static str>;

    /// If known, the symbol (as a string) for this currency.
    ///
    /// Note that this is unlikely to ever have a value for historical codes.
    #[cfg(feature = "symbols")]
    fn currency_symbol_str(&self) -> Option<&'static str>;

    /// If known, the symbol (as a list of Unicode code points) for this currency.
    ///
    /// As many countries use multi-character symbols, a list of points is returned. Note that this
    /// is unlikely to ever have a value for historical codes.
    #[cfg(feature = "symbols")]
    fn currency_symbol_code_points(&self) -> Option<&'static [u32]>;
{{ "}" }}

/// Provides an array of all defined [`{{ type_name }}`] codes, useful for queries.
pub const ALL_CODES: [&'static dyn {{ type_name }}; {{ all_ids | length }}] = [{% for id in all_ids %}
    {{ id }},{% endfor %}
];

pub use codes_common::CodeParseError as {{ type_name }}Error;

// ------------------------------------------------------------------------------------------------
// Public Constants
// ------------------------------------------------------------------------------------------------

/// The publication date of the `list-one` file used to generate active entries.
pub const ACTIVE_PUBLISH_DATE: &str = "{{ active_file_date }}";

/// The publication date of the `list-three` file used to generate historical entries.
pub const HISTORICAL_PUBLISH_DATE: &str = "{{ historical_file_date }}";

// ------------------------------------------------------------------------------------------------
// Implementations
// ------------------------------------------------------------------------------------------------

impl FromStr for &'static dyn {{ type_name }} {{ "{" }}
    type Err = {{ type_name }}Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {{ "{" }}
        match s {{ "{" }}{% for id in all_ids %}
            "{{ id }}" => Ok({{ id }}),{% endfor %}
            _ => Err(error::unknown_value("{{ type_name }}", s)),
        {{ "}" }}
    {{ "}" }}
}

// code_impl!({{ type_name }}, alpha_code);
// 
// fixed_length_code!({{ type_name }}, 3);
// 
// standardized_type!({{ type_name }}, ISO_4217);

{% for id in all_ids %}

/// An instance of [`{{id | capitalize}}`].
pub const {{ id }}: &{{ id | capitalize }} = &{{ id | capitalize }}(PhantomData);

/// {{ codes[id].currency_name }}
#[derive(Clone, Copy, Debug, Hash)]
pub struct {{ id | capitalize }}(PhantomData<()>);

impl {{ type_name }} for {{ id | capitalize }} {{ "{" }}
    fn get_concrete() -> &'static Self where Self: Sized {{ "{" }} {{ id }} {{ "}" }}

    fn alpha_code(&self) -> &'static str {{ "{" }} "{{ id }}" {{ "}" }}
    fn numeric_code(&self) -> Option<u16> {{ "{" }} {% if codes[id].numeric_code %}Some({{ codes[id].numeric_code }}){% else %}None{% endif %} {{ "}" }}
    #[cfg(feature = "currency_name")]
    fn currency_name(&self) -> &'static str {{ "{" }} "{{ codes[id].currency_name }}" {{ "}" }}
    #[cfg(feature = "country_name")]
    fn country_name(&self) -> &'static str {{ "{" }} "{{ codes[id].country_name }}" {{ "}" }}
    #[cfg(feature = "monetary_units")]
    fn monetary_units(&self) -> Option<u8> {{ "{" }} {% if codes[id].monetary_units %}Some({{ codes[id].monetary_units }}){% else %}None{% endif %} {{ "}" }}
    #[cfg(feature = "is_fund")]
    fn is_fund(&self) -> bool {{ "{" }} {% if codes[id].is_fund %}true{% else %}false{% endif %} {{ "}" }}
    #[cfg(feature = "historical_codes")]
    fn is_historical(&self) -> bool {{ "{" }} {% if codes[id].is_historical %}true{% else %}false{% endif %} {{ "}" }}
    #[cfg(feature = "historical_codes")]
    fn withdrawal_date(&self) -> Option<&'static str> {{ "{" }} {% if codes[id].withdrawal_date %}Some("{{ codes[id].withdrawal_date }}"){% else %}None{% endif %} {{ "}" }}
    #[cfg(feature = "symbols")]
    fn currency_symbol_str(&self) -> Option<&'static str> {{ "{" }} {% if codes[id].currency_string %}Some("{{ codes[id].currency_string }}"){% else %}None{% endif %} {{ "}" }}
    #[cfg(feature = "symbols")]
    fn currency_symbol_code_points(&self) -> Option<&'static [u32]> {{ "{" }} {% if codes[id].currency_code_points %}Some(&[{{ codes[id].currency_code_points | join(sep=", ") }}]){% else %}None{% endif %} {{ "}" }}
{{ "}" }}
{% endfor %}
